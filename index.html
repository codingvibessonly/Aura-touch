<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive 3D Nebula</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #111 0%, #000 100%); 
            touch-action: none; 
            cursor: none; /* Arrow hidden */
        }
    </style>
</head>
<body>

<script>
const COUNT = 8000;
let scene, camera, renderer, particles, geometry;
let targetPositions = new Float32Array(COUNT * 3);
let currentShape = 0;
let targetRotationX = 0, targetRotationY = 0;
let clock = new THREE.Clock();

// --- Initialization ---
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 60;

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// --- Particle Texture ---
const createGlowTexture = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.3, 'rgba(200,220,255,0.4)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    return new THREE.CanvasTexture(canvas);
};

// --- Geometry Construction ---
geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);
const sizes = new Float32Array(COUNT);
const colorTool = new THREE.Color();

for (let i = 0; i < COUNT; i++) {
    positions.set([(Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200], i*3);
    colorTool.setHSL(0.6 + Math.random() * 0.1, 0.8, 0.5);
    colors.set([colorTool.r, colorTool.g, colorTool.b], i*3);
    sizes[i] = Math.random();
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
    size: 1.1, 
    map: createGlowTexture(),
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
});

particles = new THREE.Points(geometry, material);
scene.add(particles);

// --- Shapes Calculation ---
function setShape(type) {
    for (let i = 0; i < COUNT; i++) {
        let x, y, z;
        if (type === 0) { // Deep Heart
            const t = Math.random() * Math.PI * 2;
            x = 16 * Math.pow(Math.sin(t), 3);
            y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            z = (Math.random() - 0.5) * 8;
        } else if (type === 1) { // Massive Saturn
            if (i < COUNT * 0.4) {
                const u = Math.random(), v = Math.random();
                const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                x = 14 * Math.sin(phi) * Math.cos(theta);
                y = 14 * Math.sin(phi) * Math.sin(theta);
                z = 14 * Math.cos(phi);
            } else {
                const angle = Math.random() * Math.PI * 2;
                const r = 22 + Math.random() * 10;
                x = r * Math.cos(angle); y = (Math.random()-0.5)*2; z = r * Math.sin(angle);
            }
        } else { // Cosmic Flower
            const t = Math.random() * Math.PI * 2;
            const r = (18 + Math.sin(clock.getElapsedTime())) * Math.sin(5 * t);
            x = r * Math.cos(t); y = r * Math.sin(t); z = Math.sin(t * 10) * 5;
        }
        targetPositions.set([x * 1.5, y * 1.5, z * 1.5], i * 3);
    }
}

setShape(0);

// --- Events ---
window.addEventListener('pointermove', (e) => {
    targetRotationY = (e.clientX - window.innerWidth / 2) * 0.0025;
    targetRotationX = (e.clientY - window.innerHeight / 2) * 0.0025;
});

window.addEventListener('pointerdown', () => {
    currentShape = (currentShape + 1) % 3;
    setShape(currentShape);
    
    // Color flash
    const hue = Math.random();
    const colorAttr = geometry.attributes.color;
    for(let i=0; i<COUNT; i++) {
        colorTool.setHSL(hue + (Math.random()*0.05), 0.9, 0.6);
        colorAttr.array[i*3] = colorTool.r;
        colorAttr.array[i*3+1] = colorTool.g;
        colorAttr.array[i*3+2] = colorTool.b;
    }
    colorAttr.needsUpdate = true;
});

// --- Main Loop ---
function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // 1. Slow Follow Rotation
    particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.04;
    particles.rotation.x += (targetRotationX - particles.rotation.x) * 0.04;

    // 2. Wave Motion (Addition)
    const posAttr = geometry.attributes.position;
    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;
        // Floating effect using Sine waves
        const wave = Math.sin(time + i) * 0.05;
        
        posAttr.array[i3] += (targetPositions[i3] - posAttr.array[i3]) * 0.02 + wave;
        posAttr.array[i3+1] += (targetPositions[i3+1] - posAttr.array[i3+1]) * 0.02 + wave;
        posAttr.array[i3+2] += (targetPositions[i3+2] - posAttr.array[i3+2]) * 0.02;
    }
    posAttr.needsUpdate = true;

    // 3. Auto-Cycle Shape every 15 seconds
    if (Math.floor(time) % 15 === 0 && Math.floor(time) !== 0 && time % 1 < 0.01) {
        // Subtle auto-switch logic could go here if needed
    }

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>